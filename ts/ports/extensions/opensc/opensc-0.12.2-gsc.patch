diff -urN opensc-0.12.2.orig/src/libopensc/card-gsc.c opensc-0.12.2/src/libopensc/card-gsc.c
--- opensc-0.12.2.orig/src/libopensc/card-gsc.c	1969-12-31 18:00:00.000000000 -0600
+++ opensc-0.12.2/src/libopensc/card-gsc.c	2012-03-20 15:09:21.319620992 -0500
@@ -0,0 +1,1077 @@
+/*
+ * card-gsc.c: Support for cards based on the Government Smart Card
+ *   Interoperability Specification 2.1 (NIST-6887 2003 edition)
+ *   Or GSC-IS 2.1 for short.
+ *
+ * Copyright (C) 2009-2011 Science Applications International Corporation
+ *   (SAIC)
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "internal.h"
+#include "cardctl.h"
+#include <string.h>
+#include <stdlib.h>
+#ifdef ENABLE_ZLIB
+#include "compression.h"
+#endif
+
+/*
+  This driver was started as a replacement for the coolkey driver
+  that was enhanced to support the US Gov't Command Access Card (CAC).
+  Unfortunately it stopped working with the release of newer cards that
+  required extended APDU commands. This was eventually fixed but not before
+  this driver was started. OpenSC provided PIV support that was also considered
+  useful as many US Gov't offices are using that data model and it would
+  be nice to maintain a single middleware for US Gov't purposes.
+
+  This driver was developed based on the NIST Interagency Report 6887 from 2003
+  The GSC-IS supports a common set of APDUs with two slightly different data
+  models.
+
+  The entry point for these cards is through the Card Capability Container, or
+  CCC located at A0 00 00 01 16 DB 00. The presence of the CCC and the ability
+  to read it properly indicates the existence of a GSC-IS card. The data
+  within the CCC indicates which data model is being used located in the
+  Registered Data Model number. 0x01 indicate a GSC data model. Anything else
+  indicates a CAC data model. It's unclear what the differences between a
+  CACv1 and CACv2 card are, and there are some differences in practice between
+  the NIST document and reality. However, it is unlikely that any older CACv1
+  cards are still around and even older CACv2 cards will disappear due to the
+  requirement to use stronger keys needing the use of extended APDUs.
+
+  The CAC model was updated to provide a Consolidate PIV+CACv2 interface. For
+  the purposes of this driver, the difference is a few additional objects
+  available and indicated in the CCC. This driver may become obsolete at some
+  time as the US Gov't moves entirely to PIV cards.
+
+  There are a few pieces missing from this implementation for reading the CCC.
+  There are some structures relating to access control and capability tuples in
+  a few of the tags of the CCC that are being ignored. None of our cards seem
+  to require this and we use the assumption that the user is going to have to
+  login to use the private key anyway, which is the primary focus of this
+  driver.
+*/
+
+/* Enable to get some card reading information to stdout */
+/*#define GSC_DEBUG*/
+
+static struct sc_card_operations gsc_ops;
+static struct sc_card_driver gsc_drv = {
+	"Driver for GSC-IS Cards",
+	"gsc",
+	&gsc_ops,
+	NULL, 0, NULL
+};
+
+typedef struct gsc_cardid {
+  u8 rid[5];
+  u8 manid;
+  u8 type;
+  size_t idsz;
+  u8 * id;
+} gsc_card_id_t;
+
+/* Each application is identified by a distinct OID
+   The RID and application ID together indicate the application APDU
+   The OID then indicates the object within the the application
+   There may be a 1 to 1 correspondence of aid to oid or an app may
+    contain multiple objects. The specification allows for both */
+typedef struct gsc_app_url {
+  u8 rid[5];
+  u8 type;
+  u8 oid[2];
+  u8 aid[2];
+} gsc_app_url_t;
+
+typedef struct gsc_private_data {
+  struct gsc_cardid cardid;
+  u8 ccver; /* CCC version, likely 2.1 */
+  u8 cgver; /* Card Grammar version, likely 2.1 */
+  u8 pkver; /* PKCS#15 version */
+  u8 rdmnum; /* Indicates the data model 0x01 = GSC, other = CAC */
+  struct gsc_app_url *apps; /* Apps based on data model and updated by CCC */
+  size_t numapps; /* Size of the apps structure */
+  size_t capp; /* Current selected/read application */
+  size_t sz_cfile; /* Size of the current selected and read file/app */
+  u8   * cfile; /* Data is read in full on first access */
+} gsc_private_data_t;
+
+/* GSC Data Model */
+/* Used a card from Axalto/Gemalto to test, and there are some
+   differences from the specification in what the tested card
+   reports in the CCC. */
+#define GSC_NUM_GSC_APPS 14
+static const struct gsc_app_url gsc_is_apps[GSC_NUM_GSC_APPS] = {
+  { "\xA0\x00\x00\x01\x16", '\x01', "\xDB\x00", "\xDB\x00" }, /* CCC */
+  { "\xA0\x00\x00\x00\x16", '\x01', "\x20\x00", "\x20\x00" }, /* General Info */
+  { "\xA0\x00\x00\x00\x16", '\x01', "\x21\x00", "\x21\x00" }, /* Personal Info */
+  { "\xA0\x00\x00\x01\x16", '\x01', "\x30\x00", "\x30\x00" }, /* Access Control */
+  { "\xA0\x00\x00\x01\x16", '\x01', "\x40\x00", "\x40\x00" }, /* Login */
+  { "\xA0\x00\x00\x01\x16", '\x01', "\x50\x00", "\x50\x00" }, /* Card Information */
+  { "\xA0\x00\x00\x01\x16", '\x04', "\x60\x00", "\x60\x00" }, /* Biometrics X.509 */
+  { "\xA0\x00\x00\x00\x16", '\x04', "\x70\x00", "\x70\x00" }, /* X.509 Certificates */
+  { "\xA0\x00\x00\x00\x16", '\x04', "\x70\x01", "\x70\x01" }, /*  More are available*/
+  { "\xA0\x00\x00\x00\x16", '\x04', "\x70\x02", "\x70\x02" }, /*  than listed in the*/
+  { "\xA0\x00\x00\x00\x16", '\x04', "\x70\x03", "\x70\x03" }, /*  spec*/
+  { "\xA0\x00\x00\x00\x16", '\x04', "\xa0\x00", "\xa0\x00" }, /* These are unknown */
+  { "\xA0\x00\x00\x00\x16", '\x04', "\xa0\x01", "\xa0\x01" },
+  { "\xA0\x00\x00\x00\x16", '\x04', "\xa0\x02", "\xa0\x02" }
+};
+
+/* PIV+CACv2 Data Model */
+/* 
+   This is the CAC data model in NIST IR 6887 Consolidated with the PIV
+   Except for the CCC, the PIV items have RID ending with 0116
+*/
+#define GSC_NUM_CAC_APPS 12
+static const struct gsc_app_url gsc_cac_apps[GSC_NUM_CAC_APPS] = {
+  { "\xA0\x00\x00\x01\x16", '\x01', "\xDB\x00", "\xDB\x00" }, /* CCC */
+  { "\xA0\x00\x00\x00\x79", '\x01', "\x03\x00", "\x03\x00" }, /* Access Control  */
+  { "\xA0\x00\x00\x00\x79", '\x01', "\x02\x00", "\x02\x00" }, /* General Inf (CACv2)*/
+  { "\xA0\x00\x00\x00\x79", '\x01', "\x02\x01", "\x02\x01" }, /* Personnel (CACv2) */
+  { "\xA0\x00\x00\x00\x79", '\x04', "\x01\x00", "\x01\x00" }, /* ID Cert */
+  { "\xA0\x00\x00\x00\x79", '\x04', "\x01\x01", "\x01\x01" }, /* Signature Cert */
+  { "\xA0\x00\x00\x00\x79", '\x04', "\x01\x02", "\x01\x02" }, /* Encryption Cert */
+  { "\xA0\x00\x00\x01\x16", '\x04', "\xA0\x01", "\xA0\x01" }, /* PIV Cert */
+  { "\xA0\x00\x00\x01\x16", '\x01', "\x30\x00", "\x30\x00" }, /* CHUID (PIV) */
+  { "\xA0\x00\x00\x01\x16", '\x01', "\x60\x10", "\x30\x00" }, /* Fingerprints (PIV) */
+  { "\xA0\x00\x00\x01\x16", '\x01', "\x60\x30", "\x30\x00" }, /* Facial img (PIV) */
+  { "\xA0\x00\x00\x01\x16", '\x01', "\x90\x00", "\x30\x00" }  /* Security Obj (PIV) */
+  /*
+    These are the older CACv1 Containers and are apparently unreachable
+  { "\xA0\x00\x00\x00\x79", '\x01', "\x02\xFB", "\x02\xFB" }, General Inf (CACv1)
+  { "\xA0\x00\x00\x00\x79", '\x01', "\x02\xFD", "\x02\xFD" }, Cert Attr (CACv1)
+  { "\xA0\x00\x00\x00\x79", '\x01', "\x02\xFE", "\x02\xFE" }, PKI Certs (CACv1)
+  */
+  /*
+    These are the JDM applets
+  { "\xA0\x00\x00\x00\x79", '\x01', "\x12\x01", "\x12\x01" }, BCAdmin
+  { "\xA0\x00\x00\x00\x79", '\x01', "\x12\x02", "\x12\x02" }, BCMedical
+  */
+  /*
+    These are legacy v1 containers that redirect to matching v2 containers
+  { "\xA0\x00\x00\x00\x79", '\x04', "\x01\xF0", "\x01\xF0" }, Identity
+  { "\xA0\x00\x00\x00\x79", '\x04', "\x01\xF1", "\x01\xF1" }, Signature 
+  { "\xA0\x00\x00\x00\x79", '\x04', "\x01\xF2", "\x01\xF2" }, Key Man
+  */
+  
+};
+
+#define GSC_DATA(card) ((gsc_private_data_t*)card->drv_data)
+
+#ifdef GSC_DEBUG
+static print_app(gsc_app_url_t *app)
+{
+  int i;
+  for(i=0; i<5; i++) {
+    printf("%x:", app->rid[i]);
+  }
+  printf(" (%x) %x:%x %x:%x\n", app->type, app->oid[0], app->oid[1], app->aid[0], app->aid[1]);
+}
+#endif
+
+/* Check that the CCC application is present and readable */
+static int gsc_select_ccc(sc_card_t *card)
+{
+  static const u8 * aid = "\xA0\x00\x00\x01\x16\xDB\x00";
+  size_t aidlen = 7;
+  u8 response[2];
+  u8 bufread[2];
+  size_t responselen = 2;
+
+  sc_apdu_t apdu;
+  int r;
+
+  SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+
+  /* Select the CCC application at the known address, similar to gsc_select_file */
+  sc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xA4, 0x04, 0x00);
+  apdu.lc = aidlen;
+  apdu.data = aid;
+  apdu.datalen = aidlen;
+  apdu.resp = NULL;
+  apdu.resplen = 0;
+  apdu.le = 0;
+
+  r = sc_transmit_apdu(card, &apdu);
+
+  SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, "Select CCC APDU Failed");
+  SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL,
+	      sc_check_sw(card, apdu.sw1, apdu.sw2), "Select CCC SW Check Failed");
+
+  sc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,
+	   "Got CCC response: aid=%x, aidlen=%d, response=%x, responselen=%d\n",
+	   aid, aidlen, apdu.resp, apdu.resplen);
+
+  sc_format_apdu(card, &apdu,
+		 response == NULL ? SC_APDU_CASE_3_SHORT : SC_APDU_CASE_4_SHORT, 0x52, 0x00, 0x00);
+
+  /* Read the first two bytes out of the tag buffer */
+  bufread[0] = '\x01';
+  bufread[1] = '\x02';
+
+  apdu.cla = 0x80;
+  apdu.lc = 2;
+  apdu.data = bufread;
+  apdu.datalen = 2;
+  apdu.resp = response;
+  apdu.resplen = responselen;
+  apdu.le = response == NULL ? 0 : responselen;
+
+  r = sc_transmit_apdu(card, &apdu);
+
+  SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, "CCC Read APDU Failed");
+
+  sc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,
+	   "Got CCC Read response: aid=%x, aidlen=%d, response=%x, responselen=%d\n",
+	   aid, aidlen, apdu.resp, apdu.resplen);
+
+  SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL,
+		 sc_check_sw(card, apdu.sw1, apdu.sw2));
+  
+}
+
+/* Used to read the tag-length buffer (x01) or the value buffer (x02)
+   buffer indicates which of the two to read. This function reads the
+   first bytes of the data to determine the size, allocates the buffer
+   into recvbuf, and then reads the data into the recvbuf. The caller
+   owns the memory allocated in recvbuf and must free it when done */
+static int gsc_read_buffer(sc_card_t *card, u8 buffer, size_t *bufsz, u8 **recvbuf)
+{
+  int r;
+  sc_apdu_t apdu;
+  u8 szbuf[2];
+  u8 bufread[2];
+  size_t pos;
+  size_t left;
+  u8 lower;
+  u8 upper;
+
+  *bufsz = 0;
+  *recvbuf = NULL;
+
+  /* Read the first two bytes to get the size of the data object */
+  SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+  sc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0x52, 0x00, 0x00);
+
+  bufread[0] = buffer;
+  bufread[1] = '\x02';
+  apdu.cla = 0x80;
+  apdu.lc = 2;
+  apdu.data = bufread;
+  apdu.datalen = 2;
+  apdu.resp = szbuf;
+  apdu.resplen = 2;
+  apdu.le = 2;
+
+  r = sc_transmit_apdu(card, &apdu);
+  SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, "GSC Read APDU Failed");
+  SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, 
+	      sc_check_sw(card, apdu.sw1, apdu.sw2),
+	      "GSC Buffer Read Status Error");
+
+  *bufsz = (szbuf[1]<<8) + szbuf[0];
+
+  if (*bufsz == 0) {
+    *recvbuf = NULL;
+    return 0;
+  }
+
+  /* Allocate and initialize our memory */
+  *recvbuf = malloc(*bufsz);
+  if (!*recvbuf)
+    SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_OUT_OF_MEMORY);
+  memset(*recvbuf, 0, *bufsz);
+
+  /* Documentation recommends reading 64 bytes at a time */
+  pos = 0;
+  while (pos < *bufsz) {
+    lower = (pos+2)%256;
+    upper = (pos+2)>>8;
+    left = *bufsz - pos;
+    if (left > 64)
+      left = 64;
+
+    sc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0x52, upper, lower);
+
+    bufread[0] = buffer;
+    bufread[1] = left;
+    apdu.cla = 0x80;
+    apdu.lc = 2;
+    apdu.data = bufread;
+    apdu.datalen = 2;
+    apdu.resp = &(*recvbuf)[pos];
+    apdu.resplen = left;
+    apdu.le = left;
+
+    r = sc_transmit_apdu(card, &apdu);
+    SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, "GSC Ext Read APDU Failed");
+
+    pos += left;
+  }
+
+  return 0;
+}
+
+/* Helper function to navigate the tag-length buffer
+   r is the position in the buffer, should initially be zero, and is
+    maintained by this function.
+   tag and size are returned and indicate the next tag and the size of
+    the value
+   sz indicates the length of the tlbuf
+   returns 1 if data was grabbed, 0 if the buffer is empty */
+static int gsc_next_tag(u8* tlbuf, int *r, u8 *tag, size_t *size, size_t sz) {
+  if ((*r) >= sz) return 0;
+
+  *tag = tlbuf[*r];
+  (*r)++;
+  *size = tlbuf[*r];
+  (*r)++;
+  if ((*size) == 0xff) {
+    *size = (tlbuf[(*r)+1]<<8) + tlbuf[*r];
+    (*r)+=2;
+  }
+
+  return 1;
+}
+
+/* Updates the apps in the private data from the CCC */
+static int gsc_handle_cardurl(sc_card_t *card, gsc_app_url_t*app)
+{
+  struct gsc_private_data *priv = GSC_DATA(card);
+  int i;
+  for (i=0; i<priv->numapps; i++) {
+    if (memcmp(app->oid, priv->apps[i].oid, 2) == 0) {
+      memcpy(&priv->apps[i], app, sizeof(gsc_app_url_t));
+      break;
+    }
+  }
+
+  if (app->oid[0] == 0xa0 && app->oid[1] == 0x01 && 
+      card->type == SC_CARD_TYPE_GSC_CAC) {
+#ifdef GSC_DEBUG
+    printf("PIV Certificate Enabled\n");
+#endif
+    card->type = SC_CARD_TYPE_GSC_PIV;
+  }
+
+#ifdef GSC_DEBUG
+  if (i==priv->numapps) {
+    printf("OID Not Known: ");
+    print_app(app);
+  } else {
+    printf("App Known: ");
+    print_app(app);
+  }
+#endif
+}
+
+/* Reads and processes the CCC data buffers */
+static int gsc_get_ccc_data(sc_card_t *card)
+{
+  int r;
+  u8 * tlbuf;
+  u8 * vbuf;
+  u8 tag;
+  size_t size;
+  size_t pos;
+
+  size_t sz_tlbuf;
+  size_t sz_vbuf;
+
+  struct gsc_private_data *priv = GSC_DATA(card);
+  struct gsc_app_url app;
+
+  /* Get the tag-length buffer */
+  r = gsc_read_buffer(card, '\x01', &sz_tlbuf, &tlbuf);
+  SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, "CCC Data TL Read Failed");
+  sc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, "TL-Buffer Length is %d", sz_tlbuf);
+
+  /* Get the value buffer */
+  r = gsc_read_buffer(card, '\x02', &sz_vbuf, &vbuf);
+  SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, "CCC Data V Read Failed");
+  sc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, "V-Buffer Length is %d", sz_vbuf);
+
+  /* Navigate our buffers and pull out the values by tags if needed */
+  pos = 0;
+  r=0;
+  while(gsc_next_tag(tlbuf, &r, &tag, &size, sz_tlbuf)) {
+    if (size <= 0) {
+    } else if (tag == 0xf0) {
+      size_t cidsz = 7*sizeof(u8);
+      memcpy(&priv->cardid, &vbuf[pos], cidsz);
+      priv->cardid.idsz = size-cidsz;
+      priv->cardid.id = malloc(priv->cardid.idsz*sizeof(u8));
+      memcpy(priv->cardid.id, &vbuf[pos+cidsz+1], priv->cardid.idsz);
+    } else if (tag == 0xf1) {
+      priv->ccver = vbuf[pos];
+    } else if (tag == 0xf2) {
+      priv->cgver = vbuf[pos];
+    } else if (tag == 0xf4) {
+      priv->pkver = vbuf[pos];
+    } else if (tag == 0xf5) {
+      priv->rdmnum = vbuf[pos];
+    } else if (tag == 0xfd) {
+      memcpy(&app, &vbuf[pos], sizeof(gsc_app_url_t));
+      sc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, "Next CCC tag is unhandled");
+    } else if (tag == 0xfe) {
+      /* Error Detection Code */
+    } else if (tag == 0xf3) {
+      /* Deferred until we know what data model we're using */
+    } else {
+#ifdef GSC_DEBUG
+      printf("Tag Unknown: %x\n", tag);
+#endif
+    }
+    pos += size;
+  }
+
+  /* Check the data model of this card and set apps */
+  if (priv->rdmnum == 0x01) {
+    card->type = SC_CARD_TYPE_GSC_IS;
+    priv->numapps = GSC_NUM_GSC_APPS;
+    priv->capp = GSC_NUM_GSC_APPS;
+    priv->apps = malloc(priv->numapps*sizeof(gsc_app_url_t));
+    memcpy(priv->apps, gsc_is_apps, priv->numapps*sizeof(gsc_app_url_t));
+  } else {
+    /* Presence of A001 in the CCC will change this to PIV types */
+    card->type = SC_CARD_TYPE_GSC_CAC;
+    priv->numapps = GSC_NUM_CAC_APPS;
+    priv->capp = GSC_NUM_CAC_APPS;
+    priv->apps = malloc(priv->numapps*sizeof(gsc_app_url_t));
+    memcpy(priv->apps, gsc_cac_apps, priv->numapps*sizeof(gsc_app_url_t));
+  }
+
+  /* Retraverse the buffers to update the apps from the CCC */
+  pos = 0;
+  r=0;
+  while(gsc_next_tag(tlbuf, &r, &tag, &size, sz_tlbuf)) {
+    if (tag == 0xf3) {
+      /* The card URL structure may contain a single entry
+	 or a TLV structure for multiple card URLs */
+      if (vbuf[pos+1]==0) {
+	memcpy(&app, &vbuf[pos], sizeof(gsc_app_url_t));
+	gsc_handle_cardurl(card, &app);
+      } else {
+	int s=0,j;
+	size_t spos, ssize;
+	u8 stag;
+	while(gsc_next_tag(&vbuf[pos], &s, &stag, &ssize, size)) {
+	  memcpy(&app, &vbuf[pos+s], sizeof(gsc_app_url_t));
+	  gsc_handle_cardurl(card, &app);
+	  s+=ssize;
+	}
+      }
+    }
+    pos += size;
+  }
+
+  free(vbuf);
+  free(tlbuf);
+
+  SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, 0);
+}
+
+/* Selects the application from the given app_url structure */
+static int gsc_select_applet(sc_card_t *card, gsc_app_url_t * app)
+{
+  u8 aid[7];
+  sc_apdu_t apdu;
+  int r;
+
+  memcpy(aid, app->rid, 5);
+  aid[5] = app->aid[0];
+  aid[6] = app->aid[1];
+
+  SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+
+  /* Select the application */
+  sc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xA4, 0x04, 0x00);
+  apdu.lc = 7;
+  apdu.data = aid;
+  apdu.datalen = 7;
+  apdu.resp = NULL;
+  apdu.resplen = 0;
+  apdu.le = 0;
+
+  r = sc_transmit_apdu(card, &apdu);
+
+  SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, "GSC AID Select Failed");
+  SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL,
+	      sc_check_sw(card, apdu.sw1, apdu.sw2), "GSC AID SW Failed");
+
+  /* Select the object within the application */
+  sc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xA4, 0x02, 0x00);
+  apdu.lc = 2;
+  apdu.data = app->oid;
+  apdu.datalen = 2;
+  apdu.resp = NULL;
+  apdu.resplen = 0;
+  apdu.le = 0;
+
+  r = sc_transmit_apdu(card, &apdu);
+
+  SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, "GSC OID Select Failed");
+  SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL,
+	      sc_check_sw(card, apdu.sw1, apdu.sw2), "GSC OID SW Failed");
+
+  SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, r);
+}
+
+/*
+  Reads data from a previously selected application object
+  The separate TL and V buffers are combined into a single TLV and
+    the combined TLV buffer is returned. The caller owns the
+    allocated memory in buf
+  The size of buf is returned in sz_buf
+  0 is returned on success, others indicate failures
+*/
+static int gsc_read_other(sc_card_t *card, u8 **buf, size_t *sz_buf)
+{
+
+  gsc_private_data_t * priv = GSC_DATA(card);
+  int r, s;
+  u8 tag;
+  size_t pos, size;
+
+  u8 * tlbuf, * vbuf, *out;
+  size_t sz_tlbuf, sz_vbuf;
+
+  *buf = NULL;
+  *sz_buf = 0;
+
+  /* Read the tag-length buffer */
+  r = gsc_read_buffer(card, '\x01', &sz_tlbuf, &tlbuf);
+  SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, "Failed to read TL-Buf");
+  sc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, "TL-Buffer Length is %d", sz_tlbuf);
+
+  /* Read the value buffer */
+  r = gsc_read_buffer(card, '\x02', &sz_vbuf, &vbuf);
+  if (r<0) free(tlbuf);
+  SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, "Failed to read V-Buf");
+  sc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, "V-Buffer Length is %d", sz_vbuf);
+
+  *sz_buf = sz_tlbuf+sz_vbuf;
+
+  *buf = malloc(*sz_buf);
+  out = *buf;
+  /* Navigate the tags and values */
+  r=0;
+  s=0;
+  pos = 0;
+  while(gsc_next_tag(tlbuf, &r, &tag, &size, sz_tlbuf)) {
+    (*out) = tag;
+    out++;
+    if (size > 255) {
+      (*out) = 0xff;
+      out++;
+      (*out) = size/256;
+      out++;
+      (*out) = size%256;
+      out++;
+    } else {
+      (*out) = size;
+      out++;
+    }
+    memcpy(out, &vbuf[pos], size);
+    out += size;
+    pos += size;
+  }
+
+  free(tlbuf);
+  free(vbuf);
+
+  SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, 0);
+}
+
+/*
+  Reads a certificate from a previously selected application object
+  Process the TL and V buffers and extracts the certificate into buf
+  The size of buf is returned in sz_buf
+  0 is returned on success, others indicate failures
+*/
+static int gsc_read_certificate(sc_card_t *card, u8 **buf, size_t *sz_buf,  const u8 *path)
+{
+  gsc_private_data_t * priv = GSC_DATA(card);
+  int r, compressed = 0, numapp = 0;
+  u8 tag;
+  size_t pos, size, loc, len=0;
+
+  u8 * tlbuf, * vbuf;
+  size_t sz_tlbuf, sz_vbuf;
+
+  *sz_buf = 0;
+  *buf = NULL;
+
+  /* Read the tag-length buffer */
+  r = gsc_read_buffer(card, '\x01', &sz_tlbuf, &tlbuf);
+  SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, "Failed to read TL-Buf");
+  sc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, "TL-Buffer Length is %d", sz_tlbuf);
+
+  /* Read the value buffer */
+  r = gsc_read_buffer(card, '\x02', &sz_vbuf, &vbuf);
+  if (r<0) free(tlbuf);
+  SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, "Failed to read V-Buf");
+  sc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, "V-Buffer Length is %d", sz_vbuf);
+
+  /* Navigate the tags and values */
+  r=0;
+  pos = 0;
+  while(gsc_next_tag(tlbuf, &r, &tag, &size, sz_tlbuf)) {
+    /* This is the tag for the certificate, store position and size */
+    if (tag == 0x70) {
+      loc = pos;
+      len = size;
+
+      /* GSC-IS model may store the compression in the first byte
+         The data model doesn't indicate this, but sample cards do */
+      if (card->type == SC_CARD_TYPE_GSC_IS) {
+	if (vbuf[pos] & 0x01) {
+	  compressed = 1;
+	  loc++;
+	  len--;
+	}
+      }
+    }
+    /* CAC cards store certificate storage params in tag 0x71
+       Sample cards indicate that the compression bits might
+       be at either of these bits */
+    else if (tag == 0x71 && card->type != SC_CARD_TYPE_GSC_IS) {
+      if (size == 1) {
+	if ((vbuf[pos] & 0x80) || (vbuf[pos] & 0x01)) {
+	  compressed = 1;
+	}
+      }
+    }
+    pos += size;
+  }
+
+  if(len==0) {
+    r = SC_ERROR_OBJECT_NOT_VALID;
+    goto cert_exit;
+  }
+
+#ifdef GSC_DEBUG
+  {
+    /* Dump the certificate data for debugging */
+    char pbuf[256];
+    sprintf(pbuf, "/tmp/cert%x%x", path[0], path[1]);
+    FILE* file =fopen(pbuf,"w");
+    fwrite(&vbuf[loc], len, 1, file);
+    fclose(file);
+  }
+#endif
+
+  r = SC_SUCCESS;
+  if (compressed) {
+    /* Uncompress into a buffer allocated by zlib */
+#ifdef ENABLE_ZLIB
+    size_t newlen = 0;
+    if(SC_SUCCESS != sc_decompress_alloc(buf, &newlen, &vbuf[loc], len, COMPRESSION_AUTO)) {
+      r = SC_ERROR_OBJECT_NOT_VALID;
+    }
+    len = newlen;
+#else
+    sc_error(card->ctx,"GSC compression not supported, no zlib");
+    r = SC_ERROR_NOT_SUPPORTED;
+#endif
+    
+  } else {
+    /* Use buffer as is */
+    *buf = malloc(len);
+    if (!buf) {
+      r = SC_ERROR_OUT_OF_MEMORY;
+    }
+    memcpy(*buf, &vbuf[loc], len);
+  }
+ cert_exit:
+
+  free(vbuf);
+  free(tlbuf);
+
+  *sz_buf = len;
+
+  if (r != SC_SUCCESS) {
+     SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, r); 
+  }
+
+  SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, 0);
+}
+
+/* Find the matching appurl for the OID in the path and
+ select the application. */
+static int gsc_select_object(sc_card_t *card, const u8 *path) {
+  gsc_private_data_t * priv = GSC_DATA(card);
+  int i, r;
+
+  for (i=0; i<priv->numapps; i++) {
+    if(priv->apps[i].oid[0] == path[0] &&
+       priv->apps[i].oid[1] == path[1]) {
+
+      /* If this is not the last loaded app select the
+	 app and clear any cache */
+      if (priv->capp != i) {
+
+	r = gsc_select_applet(card, &priv->apps[i]);
+	if (r != SC_SUCCESS) {
+	  SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, r);
+	}
+
+	if (priv->cfile) {
+	  free(priv->cfile);
+	  priv->cfile = NULL;
+	}
+
+	priv->capp = i;
+      }
+
+      SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);
+    }
+  }
+  /*printf("Select file failed: %x:%x\n", path[0], path[1]);*/
+  SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_NOT_FOUND); 
+}
+
+/* Implements the file selection for PKCS#15
+   Data objects are mapped by indicating the OID in the path
+   The common 3F00 root is stripped
+   A patch containing and OID followed by CECE indicates that
+   the certificate should be processed rather than the raw buffer */
+static int gsc_select_file(sc_card_t *card, const sc_path_t *in_path,
+	sc_file_t **file_out)
+{
+  gsc_private_data_t * priv = GSC_DATA(card);
+  sc_file_t *file = NULL;
+  int r;
+  const u8 *path;
+  int pathlen;
+	
+  SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+
+  path = in_path->value;
+  pathlen = in_path->len;
+
+  if ((pathlen == 2) && (memcmp(path, "\x3F\x00", 2) == 0)) {
+    return 0;
+  }
+	
+  /* only support single EF in current application */
+  if ((pathlen > 2) && (memcmp(path, "\x3F\x00", 2) == 0)) {
+    path += 2;
+    pathlen -= 2;
+  }
+
+  /* Find the matching appurl for the OID in the path */
+  r = gsc_select_object(card, path);
+  if (r != SC_SUCCESS) {
+    SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, r);
+  }
+
+  /* If the file output was requested read the data
+     At the moment only certificates are supported as noted
+     by the CECE in the path. Other paths are ignored. */
+  if (file_out) {
+    if (priv->cfile == NULL) {
+      size_t len = 0;
+      u8 * buf = NULL;
+      if (pathlen > 3 && path[2] == 0xCE && path[3] == 0xCE) {
+	r = gsc_read_certificate(card, &buf, &len, path);
+      } else {
+	r = gsc_read_other(card, &buf, &len);
+      }
+
+      if (r < 0) {
+	SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, r);
+      }
+
+      priv->cfile = buf;
+      priv->sz_cfile = len;
+    }
+	  
+
+    file = sc_file_new();
+    if (file == NULL)
+      SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_OUT_OF_MEMORY);
+
+    file->path = *in_path;
+
+    file->type =  SC_FILE_TYPE_DF;
+    file->shareable = 0;
+    file->ef_structure = 0;
+    file->size = priv->sz_cfile;
+    file->id = (path[0]<<8) + path[1];
+
+    *file_out = file;
+  }
+
+  SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);
+}
+
+/* Read data stored in the cache from file selection */
+static int gsc_read_binary(sc_card_t *card, unsigned int idx,
+			   unsigned char *buf, size_t count, unsigned long flags) {
+  gsc_private_data_t * priv = GSC_DATA(card);
+
+  if (priv->cfile == NULL) {
+    SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_OBJECT_NOT_VALID);
+  }
+
+  if(priv->sz_cfile < (count + idx))
+    count = priv->sz_cfile - idx;
+  if(count >= 0)
+    memcpy(buf, priv->cfile + idx, count);
+
+  SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, count);
+}
+
+/* Request a challenge from the card */
+static int gsc_get_challenge(sc_card_t *card, u8 *rnd, size_t len)
+{
+  int r;
+  sc_apdu_t apdu;
+
+  SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+
+  sc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0x84, 0x00, 0x00);
+
+  apdu.lc = 0;
+  apdu.data = NULL;
+  apdu.datalen = 0;
+  apdu.resp = rnd;
+  apdu.resplen = len;
+  apdu.le = len;
+
+  r = sc_transmit_apdu(card, &apdu);
+  SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, r);
+}
+
+/* Set the security parameters
+   Card seems to only support RSA */
+static int gsc_set_security_env(sc_card_t *card,
+                    const sc_security_env_t *env,
+                    int se_num)
+{
+  int r;
+  gsc_private_data_t * priv = GSC_DATA(card);
+
+  SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+
+  sc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, "flags=%08x op=%d alg=%d algf=%08x algr=%08x "
+	   "kr0=%02x, krfl=%d\n", env->flags, env->operation,
+	   env->algorithm, env->algorithm_flags, env->algorithm_ref,
+	   env->key_ref[0], env->key_ref_len);
+
+
+  if (env->algorithm != SC_ALGORITHM_RSA) 
+    SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_NO_CARD_SUPPORT);
+
+  SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);
+}
+
+
+/* Nothing really needed for resetting the security params */
+static int gsc_restore_security_env(sc_card_t *card, int se_num)
+{
+  SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+
+  SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, 0);
+}
+
+/* Common function used for signing and decrypting */
+static int gsc_sign_decrypt(sc_card_t *card, const u8 * data, size_t datalen,
+			    u8 * out, size_t outlen)
+{
+  /* AFAIK there will never be anything more than 1024 bit key sizes
+     Output is truncated to 2048 bits despite the fact that 1024 bits
+     should be enough */
+  int r;
+  sc_apdu_t apdu;
+
+  SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+  sc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,
+	   "sign_decrypt: inlen=%d outlen=%d", datalen, outlen);
+
+  /* We can only send 255 bytes at a time */
+  while (datalen > 255) {
+    sc_apdu_t tapdu;
+    sc_format_apdu(card, &tapdu, SC_APDU_CASE_3_SHORT, 0x42, 0x80, 0x00);
+
+    tapdu.cla = 0x80;
+    tapdu.lc = 0xEF;
+    tapdu.data = data;
+    tapdu.datalen = 0xEF;
+    tapdu.resp = NULL;
+    tapdu.resplen = 0;
+    tapdu.le = 0;
+
+    r = sc_transmit_apdu(card, &tapdu);
+    if (r < 0)
+      SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, r);
+    r = sc_check_sw(card, tapdu.sw1, tapdu.sw2);
+    if (r < 0)
+      SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, r);
+
+    data += 0xEF;
+    datalen -= 0xEF;
+  }
+
+  /* Read our encrypted data, truncated to 256 bytes */
+  sc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0x42, 0x00, 0x00);
+
+  apdu.cla = 0x80;
+  apdu.lc = datalen;
+  apdu.data = data;
+  apdu.datalen = datalen;
+  apdu.resp = out;
+  apdu.resplen = outlen;
+  apdu.le = outlen>256?256:outlen;
+
+  r = sc_transmit_apdu(card, &apdu);
+  if (r < 0)
+    SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, r);
+  r = sc_check_sw(card, apdu.sw1, apdu.sw2);
+  if (r < 0)
+    SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, r);
+
+  SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, apdu.resplen);
+}
+
+/* Get the card serial number from the card ID structure */
+static int gsc_get_serial_num(sc_card_t* card, sc_serial_number_t* serial)
+{
+  gsc_private_data_t * priv = GSC_DATA(card);
+  int r;
+  size_t slen = priv->cardid.idsz;
+
+  //r = gsc_select_applet(card, priv->apps[14]);
+  //if (r < 0) return SC_ERROR_NOT_SUPPORTED;
+
+  serial->len = slen < SC_MAX_SERIALNR ? slen : SC_MAX_SERIALNR;
+  memcpy (serial->value, priv->cardid.id, serial->len);  
+
+  return 0;
+}
+
+/* Implement the card control, right now only the serial number */
+static int gsc_card_ctl(sc_card_t *card, unsigned long cmd, void *ptr)
+{
+  switch(cmd) {
+  case SC_CARDCTL_GET_SERIALNR:
+    return gsc_get_serial_num(card, (sc_serial_number_t *) ptr);
+    break;
+  }
+
+  return SC_ERROR_NOT_SUPPORTED;
+}
+
+/* Cleanup dynamically allocated data */
+static int gsc_finish(sc_card_t *card)
+{
+  gsc_private_data_t * priv = GSC_DATA(card);
+
+  SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+  if (priv) {
+    if (priv->cfile) {
+      free(priv->cfile);
+    }
+    if (priv->apps) {
+      free(priv->apps);
+    }
+    if (priv->cardid.id) {
+      free(priv->cardid.id);
+    }
+    free(priv);
+  }
+  return 0;
+}
+
+/* See if this is a GSC-IS card by searching for CCC */
+static int gsc_match_card(sc_card_t *card)
+{
+
+  int i;
+  SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+  /* Since we send an APDU, the card's logout function may be called...
+   * however it may be in dirty memory */
+  card->ops->logout = NULL;
+
+  /* Detect by selecting applet */
+  i = !(gsc_select_ccc(card));
+  return i;
+}
+
+/* Initialize the driver by reading in the CCC
+ and setting necessary parameters */
+static int gsc_init(sc_card_t *card)
+{
+  int r;
+  gsc_private_data_t *priv;
+  unsigned long flags;
+
+  SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+  priv = (gsc_private_data_t *) malloc(sizeof(gsc_private_data_t));
+  if (!priv)
+    SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_OUT_OF_MEMORY);
+  priv->apps = NULL;
+  priv->numapps = 0;
+  priv->capp = 0;
+  priv->cfile = NULL;
+  priv->cardid.id = NULL;
+	
+  card->name = "GSC-IS Card";
+  card->cla = 0x00;
+  card->drv_data = priv;
+
+  flags = SC_ALGORITHM_RSA_RAW;
+  flags |= SC_ALGORITHM_RSA_HASH_NONE;
+
+
+  _sc_card_add_rsa_alg(card, 1024, flags, 0); /* manditory */
+  _sc_card_add_rsa_alg(card, 2048, flags, 0); /* optional */
+  //_sc_card_add_rsa_alg(card, 3072, flags, 0); /* optional */
+
+  card->caps |= SC_CARD_CAP_RNG;
+  r = gsc_get_ccc_data(card);
+  SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, r);
+}
+
+static struct sc_card_driver * sc_get_driver(void)
+{
+  struct sc_card_driver *iso_drv = sc_get_iso7816_driver();
+
+  gsc_ops = *iso_drv->ops;
+  gsc_ops.match_card = gsc_match_card;
+  gsc_ops.init = gsc_init;
+  gsc_ops.finish = gsc_finish;
+  gsc_ops.select_file = gsc_select_file;
+  gsc_ops.read_binary = gsc_read_binary;
+  gsc_ops.get_challenge = gsc_get_challenge;
+  gsc_ops.set_security_env = gsc_set_security_env;
+  gsc_ops.restore_security_env = gsc_restore_security_env;
+  gsc_ops.compute_signature = gsc_sign_decrypt;
+  gsc_ops.decipher =  gsc_sign_decrypt;
+  gsc_ops.card_ctl = gsc_card_ctl;
+
+  return &gsc_drv;
+}
+
+#if 1
+struct sc_card_driver * sc_get_gsc_driver(void)
+{
+  return sc_get_driver();
+}
+#endif
diff -urN opensc-0.12.2.orig/src/libopensc/cards.h opensc-0.12.2/src/libopensc/cards.h
--- opensc-0.12.2.orig/src/libopensc/cards.h	2011-07-05 06:28:53.000000000 -0500
+++ opensc-0.12.2/src/libopensc/cards.h	2012-03-20 15:09:21.320620980 -0500
@@ -186,6 +186,12 @@
 	SC_CARD_TYPE_IASECC_GEMALTO,
 	SC_CARD_TYPE_IASECC_OBERTHUR,
 	SC_CARD_TYPE_IASECC_SAGEM,
+ 
+	/* GSC-IS cards */
+	SC_CARD_TYPE_GSC_BASE= 26000,
+	SC_CARD_TYPE_GSC_IS,
+	SC_CARD_TYPE_GSC_CAC,
+	SC_CARD_TYPE_GSC_PIV
 };
 
 extern sc_card_driver_t *sc_get_default_driver(void);
@@ -220,6 +226,7 @@
 extern sc_card_driver_t *sc_get_itacns_driver(void);
 extern sc_card_driver_t *sc_get_authentic_driver(void);
 extern sc_card_driver_t *sc_get_iasecc_driver(void);
+extern sc_card_driver_t *sc_get_gsc_driver(void);
 
 #ifdef __cplusplus
 }
diff -urN opensc-0.12.2.orig/src/libopensc/ctx.c opensc-0.12.2/src/libopensc/ctx.c
--- opensc-0.12.2.orig/src/libopensc/ctx.c	2011-07-05 06:28:53.000000000 -0500
+++ opensc-0.12.2/src/libopensc/ctx.c	2012-03-20 15:09:21.322620955 -0500
@@ -102,6 +102,9 @@
 	{ "setcos",	(void *(*)(void)) sc_get_setcos_driver },
 	{ "muscle",	(void *(*)(void)) sc_get_muscle_driver },
 	{ "atrust-acos",(void *(*)(void)) sc_get_atrust_acos_driver },
+	/* In most cases, the GSC driver needs to take precedence over PIV
+	   in the dual cards. At least for now anyway */
+	{ "gsc",        (void *(*)(void)) sc_get_gsc_driver },
 	{ "PIV-II",	(void *(*)(void)) sc_get_piv_driver },
 	{ "itacns",	(void *(*)(void)) sc_get_itacns_driver },
 	/* javacard without supported applet - last before default */
diff -urN opensc-0.12.2.orig/src/libopensc/Makefile.am opensc-0.12.2/src/libopensc/Makefile.am
--- opensc-0.12.2.orig/src/libopensc/Makefile.am	2011-07-05 06:28:53.000000000 -0500
+++ opensc-0.12.2/src/libopensc/Makefile.am	2012-03-20 15:09:21.361620467 -0500
@@ -46,6 +46,7 @@
 	pkcs15-esinit.c pkcs15-westcos.c pkcs15-pteid.c pkcs15-oberthur.c \
 	pkcs15-itacns.c pkcs15-gemsafeV1.c \
 	compression.c p15card-helper.c \
+	card-gsc.c pkcs15-gsc.c \
 	libopensc.exports
 if WIN32
 libopensc_la_SOURCES += $(top_builddir)/win32/versioninfo.rc
diff -urN opensc-0.12.2.orig/src/libopensc/Makefile.in opensc-0.12.2/src/libopensc/Makefile.in
--- opensc-0.12.2.orig/src/libopensc/Makefile.in	2011-07-15 05:47:01.000000000 -0500
+++ opensc-0.12.2/src/libopensc/Makefile.in	2012-03-20 15:09:21.364620430 -0500
@@ -106,6 +106,7 @@
 	pkcs15-esinit.c pkcs15-westcos.c pkcs15-pteid.c \
 	pkcs15-oberthur.c pkcs15-itacns.c pkcs15-gemsafeV1.c \
 	compression.c p15card-helper.c libopensc.exports \
+	card-gsc.c pkcs15-gsc.c \
 	$(top_builddir)/win32/versioninfo.rc
 am__dirstamp = $(am__leading_dot)dirstamp
 @WIN32_TRUE@am__objects_1 = $(top_builddir)/win32/versioninfo.lo
@@ -130,7 +131,7 @@
 	pkcs15-tccardos.lo pkcs15-piv.lo pkcs15-esinit.lo \
 	pkcs15-westcos.lo pkcs15-pteid.lo pkcs15-oberthur.lo \
 	pkcs15-itacns.lo pkcs15-gemsafeV1.lo compression.lo \
-	p15card-helper.lo $(am__objects_1)
+	p15card-helper.lo card-gsc.lo pkcs15-gsc.lo $(am__objects_1)
 libopensc_la_OBJECTS = $(am_libopensc_la_OBJECTS)
 AM_V_lt = $(am__v_lt_$(V))
 am__v_lt_ = $(am__v_lt_$(AM_DEFAULT_VERBOSITY))
@@ -249,7 +250,6 @@
 PACKAGE_NAME = @PACKAGE_NAME@
 PACKAGE_STRING = @PACKAGE_STRING@
 PACKAGE_TARNAME = @PACKAGE_TARNAME@
-PACKAGE_URL = @PACKAGE_URL@
 PACKAGE_VERSION = @PACKAGE_VERSION@
 PATH_SEPARATOR = @PATH_SEPARATOR@
 PCSC_CFLAGS = @PCSC_CFLAGS@
@@ -366,6 +366,7 @@
 	pkcs15-actalis.c pkcs15-atrust-acos.c pkcs15-tccardos.c \
 	pkcs15-piv.c pkcs15-esinit.c pkcs15-westcos.c pkcs15-pteid.c \
 	pkcs15-oberthur.c pkcs15-itacns.c pkcs15-gemsafeV1.c \
+	card-gsc.c pkcs15-gsc.c \
 	compression.c p15card-helper.c libopensc.exports \
 	$(am__append_1)
 libopensc_la_LIBADD = $(OPTIONAL_OPENSSL_LIBS) $(OPTIONAL_OPENCT_LIBS) \
@@ -484,6 +485,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/card-flex.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/card-gemsafeV1.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/card-gpk.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/card-gsc.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/card-ias.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/card-iasecc.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/card-incrypto34.Plo@am__quote@
@@ -527,6 +529,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pkcs15-esteid.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pkcs15-gemsafeGPK.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pkcs15-gemsafeV1.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pkcs15-gsc.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pkcs15-infocamere.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pkcs15-itacns.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pkcs15-oberthur.Plo@am__quote@
diff -urN opensc-0.12.2.orig/src/libopensc/pkcs15-gsc.c opensc-0.12.2/src/libopensc/pkcs15-gsc.c
--- opensc-0.12.2.orig/src/libopensc/pkcs15-gsc.c	1969-12-31 18:00:00.000000000 -0600
+++ opensc-0.12.2/src/libopensc/pkcs15-gsc.c	2012-03-20 15:09:21.365620417 -0500
@@ -0,0 +1,346 @@
+/*
+ * partial PKCS15 emulation for GSC-IS Version 2.1 cards
+ * only minimal use of the authentication cert and key
+ *
+ * Copyright (C) 2005,2006,2007 Douglas E. Engert <deengert@anl.gov> 
+ *               2004, Nils Larsch <larsch@trustcenter.de>
+ * Copyright (C) 2006, Identity Alliance, 
+ *               Thomas Harning <thomas.harning@identityalliance.com>
+ * Copyright (C) 2007, EMC, Russell Larner <rlarner@rsa.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "internal.h"
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <ctype.h>
+#include "pkcs15.h"
+#include "cardctl.h"
+
+#include "pkcs15-piv.h"
+
+#define MANU_ID		"gsc_is "
+#define GSC_IS_NUM_CERTS_AND_KEYS 3
+#define GSC_CAC_NUM_CERTS_AND_KEYS 4
+
+int sc_pkcs15emu_gsc_init_ex(sc_pkcs15_card_t *, sc_pkcs15emu_opt_t *);
+
+
+static int gsc_detect_card(sc_pkcs15_card_t *p15card)
+{
+	sc_card_t *card = p15card->card;
+
+	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+	if (card->type < SC_CARD_TYPE_GSC_IS
+		|| card->type > SC_CARD_TYPE_GSC_PIV)
+		return SC_ERROR_INVALID_CARD;
+	return SC_SUCCESS;
+}
+
+static int sc_pkcs15emu_gsc_is_init(sc_pkcs15_card_t *p15card)
+{
+
+  /* The cert objects will return all the data */
+  static const objdata objects[] = {
+    {"1", "Card Capability Container", 
+     "2.16.840.1.101.3.7.1.219.0", NULL, "DB00", 0},
+    {"2", "General Information",
+     "2.16.840.1.101.3.7.2.48.1", NULL, "2000", 0},
+    {"3", "Personal Information",
+     "2.16.840.1.101.3.7.2.48.2", "1", "2100", SC_PKCS15_CO_FLAG_PRIVATE},
+    {"4", "Access Control",
+     "2.16.840.1.101.3.7.2.48.0", NULL, "3000", 0},
+    {"5", "Login",
+     "2.16.840.1.101.3.7.2.96.16", "1", "4000", SC_PKCS15_CO_FLAG_PRIVATE},
+    {"6", "Card Information", 
+     "2.16.840.1.101.3.7.2.96.48", NULL, "5000", 0},
+    {"7", "X.509 Certificate for Biometrics", 
+     "2.16.840.1.101.3.7.2.1.3", NULL, "6000", 0},
+    {"8", "X.509 Certificate for CAC Identification",
+     "2.16.840.1.101.3.7.2.1.1", NULL, "7001", 0},
+    {"9", "X.509 Certificate for Email Signature",
+     "2.16.840.1.101.3.7.2.1.0",  NULL, "7002", 0},
+    {"10", "X.509 Certificate for Email Encryption", 
+     "2.16.840.1.101.3.7.2.1.2", NULL, "7003", 0},
+    {NULL, NULL, NULL, NULL, NULL, 0}
+};
+  /* 
+   * NIST 800-73-1 is proposing to lift the restriction on 
+   * requering pin protected certs. Thus the default will be to 
+   * not require this. But there are a number of test cards 
+   * that do enforce it. Code later on will allow SC_PKCS15_CO_FLAG_PRIVATE
+   * to be set. 
+   */
+  /* certs will be pulled out from the cert objects */
+  static const cdata certs[GSC_IS_NUM_CERTS_AND_KEYS] = {
+    {"1", "ID Certificate", 0, "7001cece", 0},
+    {"2", "Email Signature Certificate", 0, "7002cece", 0},
+    {"3", "Email Encryption Certificate", 0, "7003cece", 0}
+  };
+
+  static const pindata pins[] = {
+    { "1", "GSC", "", 0x00,
+      SC_PKCS15_PIN_TYPE_ASCII_NUMERIC,
+      8, 4, 8, 
+      SC_PKCS15_PIN_FLAG_NEEDS_PADDING |
+      SC_PKCS15_PIN_FLAG_LOCAL, 
+      -1, 0xFF,
+      SC_PKCS15_CO_FLAG_PRIVATE },
+    /* Don't know where the PUK is
+       { "2", "PUK", "", 0x81, 
+       SC_PKCS15_PIN_TYPE_ASCII_NUMERIC,
+       8, 4, 8, 
+       SC_PKCS15_PIN_FLAG_NEEDS_PADDING |
+       SC_PKCS15_PIN_FLAG_LOCAL | SC_PKCS15_PIN_FLAG_SO_PIN |
+       SC_PKCS15_PIN_FLAG_UNBLOCKING_PIN, 
+       -1, 0xFF, 
+       SC_PKCS15_CO_FLAG_PRIVATE },
+    */
+    { NULL, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 0}
+  };
+
+
+  /*
+   * The size of the key or the algid is not really known
+   * but can be derived from the certificates. 
+   * the cert, pubkey and privkey are a set. 
+   * Key usages bits taken from pkcs15v1_1 Table 2
+   */
+  static const pubdata pubkeys[] = {
+    /* Pubkeys aren't stored separately - let cert make them */
+    { "1", "ID pubkey", 
+      /*RSA*/SC_PKCS15_PRKEY_USAGE_VERIFY |
+      SC_PKCS15_PRKEY_USAGE_VERIFYRECOVER |
+      SC_PKCS15_PRKEY_USAGE_NONREPUDIATION,
+      /*EC*/SC_PKCS15_PRKEY_USAGE_VERIFY |
+      SC_PKCS15_PRKEY_USAGE_NONREPUDIATION,
+      "", 1, "1", 0, NULL},
+    { "2", "Email Signature pubkey",
+      /*RSA*/SC_PKCS15_PRKEY_USAGE_VERIFY |
+      SC_PKCS15_PRKEY_USAGE_VERIFYRECOVER |
+      SC_PKCS15_PRKEY_USAGE_NONREPUDIATION,
+      /*EC*/SC_PKCS15_PRKEY_USAGE_VERIFY |
+      SC_PKCS15_PRKEY_USAGE_NONREPUDIATION,
+      "", 2, "1", 0, NULL},
+    { "3", "Email Encryption pubkey", 
+      /*RSA*/SC_PKCS15_PRKEY_USAGE_ENCRYPT |
+      SC_PKCS15_PRKEY_USAGE_WRAP,
+      /*EC*/SC_PKCS15_PRKEY_USAGE_ENCRYPT,
+      "", 3, "1", 0, NULL}
+		
+  };
+
+  static const prdata prkeys[] = {
+    { "1", "ID key", 
+      /*RSA*/SC_PKCS15_PRKEY_USAGE_SIGN |
+      SC_PKCS15_PRKEY_USAGE_SIGNRECOVER |
+      SC_PKCS15_PRKEY_USAGE_NONREPUDIATION,
+      /*EC*/SC_PKCS15_PRKEY_USAGE_SIGN |
+      SC_PKCS15_PRKEY_USAGE_NONREPUDIATION,
+      "7001", 1, "1", SC_PKCS15_CO_FLAG_PRIVATE, 1},
+    { "2", "Email Signature key", 
+      /*RSA*/SC_PKCS15_PRKEY_USAGE_SIGN |
+      SC_PKCS15_PRKEY_USAGE_SIGNRECOVER |
+      SC_PKCS15_PRKEY_USAGE_NONREPUDIATION,
+      /*EC*/SC_PKCS15_PRKEY_USAGE_SIGN |
+      SC_PKCS15_PRKEY_USAGE_NONREPUDIATION,
+      "7002", 2, "1", SC_PKCS15_CO_FLAG_PRIVATE, 1},
+    { "3", "Email Encryption key",
+      /*RSA*/SC_PKCS15_PRKEY_USAGE_DECRYPT |
+      SC_PKCS15_PRKEY_USAGE_UNWRAP,
+      /*RSA*/SC_PKCS15_PRKEY_USAGE_DECRYPT,
+      "7003", 3, "1", SC_PKCS15_CO_FLAG_PRIVATE, 1}
+  };
+
+  common_key_info ckis[GSC_IS_NUM_CERTS_AND_KEYS];
+
+  return sc_pkcs15emu_piv_init_helper(p15card, "GSC-IS", "GSC", MANU_ID,
+				      objects, GSC_IS_NUM_CERTS_AND_KEYS,
+				      certs, pins, pubkeys, prkeys, ckis);
+}
+
+static int sc_pkcs15emu_gsc_cac_init(sc_pkcs15_card_t *p15card)
+{
+
+  /* The cert objects will return all the data */
+  static const objdata objects[] = {
+    {"1", "Card Capability Container", 
+     "2.16.840.1.101.3.7.1.219.0", NULL, "DB00", 0},
+    {"2", "General Information",
+     "2.16.840.1.101.3.7.2.48.1", "1", "0200", SC_PKCS15_CO_FLAG_PRIVATE},
+    {"3", "Personnel Information",
+     "2.16.840.1.101.3.7.2.48.2", "1", "0201", SC_PKCS15_CO_FLAG_PRIVATE},
+    {"4", "Card Holder Unique Identifier",
+     "2.16.840.1.101.3.7.2.48.0", NULL, "3000", 0},
+    {"5", "Card Holder Fingerprints",
+     "2.16.840.1.101.3.7.2.96.16", "1", "6010", SC_PKCS15_CO_FLAG_PRIVATE},
+    {"6", "Card Holder Facial Image", 
+     "2.16.840.1.101.3.7.2.96.48", "1", "6030", SC_PKCS15_CO_FLAG_PRIVATE},
+    {"7", "X.509 Certificate for CAC Identification",
+     "2.16.840.1.101.3.7.2.1.1", NULL, "0100", 0},
+    {"8", "X.509 Certificate for Email Signature",
+     "2.16.840.1.101.3.7.2.1.0",  NULL, "0101", 0},
+    {"9", "X.509 Certificate for Email Encryption", 
+     "2.16.840.1.101.3.7.2.1.2", NULL, "0102", 0},
+    {"10", "X.509 Certificate for PIV Authentication", 
+     "2.16.840.1.101.3.7.2.1.3", NULL, "A001", 0},
+    {"11", "Security Object",
+     "2.16.840.1.101.3.7.2.144.0", NULL, "9000", 0},
+    {NULL, NULL, NULL, NULL, NULL, 0}
+  };
+
+  /* 
+   * NIST 800-73-1 is proposing to lift the restriction on 
+   * requering pin protected certs. Thus the default will be to 
+   * not require this. But there are a number of test cards 
+   * that do enforce it. Code later on will allow SC_PKCS15_CO_FLAG_PRIVATE
+   * to be set. 
+   */
+  /* certs will be pulled out from the cert objects */
+  static const cdata certs[GSC_CAC_NUM_CERTS_AND_KEYS] = {
+    {"1", "ID Certificate", 0, "0100cece", 0},
+    {"2", "Email Signature Certificate", 0, "0101cece", 0},
+    {"3", "Email Encryption Certificate", 0, "0102cece", 0},
+    {"4", "PIV Authentication Certificate", 0, "a001cece", 0}
+  };
+
+  static const pindata pins[] = {
+    { "1", "CAC", "", 0x00,
+      SC_PKCS15_PIN_TYPE_ASCII_NUMERIC,
+      8, 4, 8, 
+      SC_PKCS15_PIN_FLAG_NEEDS_PADDING |
+      SC_PKCS15_PIN_FLAG_LOCAL, 
+      -1, 0xFF,
+      SC_PKCS15_CO_FLAG_PRIVATE },
+    /* Don't know where the PUK is
+       { "2", "PUK", "", 0x81, 
+       SC_PKCS15_PIN_TYPE_ASCII_NUMERIC,
+       8, 4, 8, 
+       SC_PKCS15_PIN_FLAG_NEEDS_PADDING |
+       SC_PKCS15_PIN_FLAG_LOCAL | SC_PKCS15_PIN_FLAG_SO_PIN |
+       SC_PKCS15_PIN_FLAG_UNBLOCKING_PIN, 
+       -1, 0xFF, 
+       SC_PKCS15_CO_FLAG_PRIVATE },
+    */
+    { NULL, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 0}
+  };
+
+
+  /*
+   * The size of the key or the algid is not really known
+   * but can be derived from the certificates. 
+   * the cert, pubkey and privkey are a set. 
+   * Key usages bits taken from pkcs15v1_1 Table 2
+   */
+  static const pubdata pubkeys[] = {
+    /* Pubkeys aren't stored separately - let cert make them */
+    { "1", "ID pubkey", 
+      /*RSA*/SC_PKCS15_PRKEY_USAGE_VERIFY |
+      SC_PKCS15_PRKEY_USAGE_VERIFYRECOVER |
+      SC_PKCS15_PRKEY_USAGE_NONREPUDIATION,
+      /*EC*/SC_PKCS15_PRKEY_USAGE_VERIFY |
+      SC_PKCS15_PRKEY_USAGE_NONREPUDIATION,
+      "", 1, "1", 0, NULL},
+    { "2", "Email Signature pubkey",
+      /*RSA*/SC_PKCS15_PRKEY_USAGE_VERIFY |
+      SC_PKCS15_PRKEY_USAGE_VERIFYRECOVER |
+      SC_PKCS15_PRKEY_USAGE_NONREPUDIATION,
+      /*EC*/SC_PKCS15_PRKEY_USAGE_VERIFY |
+      SC_PKCS15_PRKEY_USAGE_NONREPUDIATION,
+      "", 2, "1", 0, NULL},
+    { "3", "Email Encryption pubkey", 
+      /*RSA*/SC_PKCS15_PRKEY_USAGE_ENCRYPT |
+      SC_PKCS15_PRKEY_USAGE_WRAP,
+      /*EC*/SC_PKCS15_PRKEY_USAGE_ENCRYPT,
+      "", 3, "1", 0, NULL},
+    { "4", "PIV pubkey", 
+      /*RSA*/SC_PKCS15_PRKEY_USAGE_VERIFY |
+      SC_PKCS15_PRKEY_USAGE_VERIFYRECOVER |
+      SC_PKCS15_PRKEY_USAGE_NONREPUDIATION,
+      /*EC*/SC_PKCS15_PRKEY_USAGE_VERIFY |
+      SC_PKCS15_PRKEY_USAGE_NONREPUDIATION,
+      "", 4, "1", 0, NULL},
+		
+  };
+
+  static const prdata prkeys[] = {
+    { "1", "ID key", 
+      /*RSA*/SC_PKCS15_PRKEY_USAGE_SIGN |
+      SC_PKCS15_PRKEY_USAGE_SIGNRECOVER |
+      SC_PKCS15_PRKEY_USAGE_NONREPUDIATION,
+      /*EC*/SC_PKCS15_PRKEY_USAGE_SIGN |
+      SC_PKCS15_PRKEY_USAGE_NONREPUDIATION,
+      "0100", 1, "1", SC_PKCS15_CO_FLAG_PRIVATE, 1},
+    { "2", "Email Signature key", 
+      /*RSA*/SC_PKCS15_PRKEY_USAGE_SIGN |
+      SC_PKCS15_PRKEY_USAGE_SIGNRECOVER |
+      SC_PKCS15_PRKEY_USAGE_NONREPUDIATION,
+      /*EC*/SC_PKCS15_PRKEY_USAGE_SIGN |
+      SC_PKCS15_PRKEY_USAGE_NONREPUDIATION,
+      "0101", 2, "1", SC_PKCS15_CO_FLAG_PRIVATE, 1},
+    { "3", "Email Encryption key",
+      /*RSA*/SC_PKCS15_PRKEY_USAGE_DECRYPT |
+      SC_PKCS15_PRKEY_USAGE_UNWRAP,
+      /*RSA*/SC_PKCS15_PRKEY_USAGE_DECRYPT,
+      "0102", 3, "1", SC_PKCS15_CO_FLAG_PRIVATE, 1},
+    { "4", "PIV key", 
+      /*RSA*/SC_PKCS15_PRKEY_USAGE_SIGN |
+      SC_PKCS15_PRKEY_USAGE_SIGNRECOVER |
+      SC_PKCS15_PRKEY_USAGE_NONREPUDIATION,
+      /*EC*/SC_PKCS15_PRKEY_USAGE_SIGN |
+      SC_PKCS15_PRKEY_USAGE_NONREPUDIATION,
+      "a001", 4, "1", SC_PKCS15_CO_FLAG_PRIVATE, 1}
+  };
+
+  common_key_info ckis[GSC_CAC_NUM_CERTS_AND_KEYS];
+
+  if (p15card->card->type == SC_CARD_TYPE_GSC_PIV)
+    return sc_pkcs15emu_piv_init_helper(p15card, "GSC-CAC", "GSC", MANU_ID,
+					objects, GSC_CAC_NUM_CERTS_AND_KEYS,
+					certs, pins, pubkeys, prkeys, ckis);
+  else
+    return sc_pkcs15emu_piv_init_helper(p15card, "GSC-CAC", "GSC", MANU_ID,
+					objects, GSC_CAC_NUM_CERTS_AND_KEYS-1,
+					certs, pins, pubkeys, prkeys, ckis);
+}
+
+int sc_pkcs15emu_gsc_init(sc_pkcs15_card_t *p15card)
+{
+  if (p15card->card->type == SC_CARD_TYPE_GSC_IS)
+    return sc_pkcs15emu_gsc_is_init(p15card);
+  else
+    return sc_pkcs15emu_gsc_cac_init(p15card);
+}
+
+
+int sc_pkcs15emu_gsc_init_ex(sc_pkcs15_card_t *p15card,
+				  sc_pkcs15emu_opt_t *opts)
+{
+	sc_card_t   *card = p15card->card;
+	sc_context_t    *ctx = card->ctx;
+
+	SC_FUNC_CALLED(ctx, SC_LOG_DEBUG_VERBOSE);
+
+	if (opts && opts->flags & SC_PKCS15EMU_FLAGS_NO_CHECK)
+		return sc_pkcs15emu_gsc_init(p15card);
+	else {
+		int r = gsc_detect_card(p15card);
+		if (r)
+			return SC_ERROR_WRONG_CARD;
+		return sc_pkcs15emu_gsc_init(p15card);
+	}
+}
diff -urN opensc-0.12.2.orig/src/libopensc/pkcs15-piv.c opensc-0.12.2/src/libopensc/pkcs15-piv.c
--- opensc-0.12.2.orig/src/libopensc/pkcs15-piv.c	2011-07-05 06:28:53.000000000 -0500
+++ opensc-0.12.2/src/libopensc/pkcs15-piv.c	2012-03-20 15:12:36.574179974 -0500
@@ -35,77 +35,16 @@
 #include "cardctl.h"
 #include "asn1.h"
 #include "pkcs15.h"
+ 
+#include "pkcs15-piv.h"
+#ifdef ENABLE_OPENSSL
+#include <openssl/x509v3.h>
+#endif
 
 #define MANU_ID		"piv_II "
 
 int sc_pkcs15emu_piv_init_ex(sc_pkcs15_card_t *, sc_pkcs15emu_opt_t *);
 
-typedef struct objdata_st {
-	const char *id;
-	const char *label;
-	const char *aoid;
-	const char *auth_id;
-	const char *path;
-	int         obj_flags;
-} objdata;
-
-typedef struct cdata_st {
-	const char *id;
-	const char *label;
-	int	    authority;
-	const char *path;
-	int         obj_flags;
-} cdata;
-
-typedef struct pdata_st {
-	const char *id;
-	const char *label;
-	const char *path;
-	int         ref;
-	int         type;
-	unsigned int maxlen;
-	unsigned int minlen;
-	unsigned int storedlen;
-	int         flags;	
-	int         tries_left;
-	const unsigned char  pad_char;
-	int         obj_flags;
-} pindata; 
-
-typedef struct pubdata_st {
-	const char *id;
-	const char *label;
-	int         usage_rsa;
-	int         usage_ec;
-	const char *path;
-	int         ref;
-	const char *auth_id;
-	int         obj_flags;
-	const char *getenvname;
-} pubdata;
-
-typedef struct prdata_st {
-	const char *id;
-	const char *label;
-	int         usage_rsa;
-	int			usage_ec;
-	const char *path;
-	int         ref;
-	const char *auth_id;
-	int         obj_flags;
-	int			user_consent; 
-} prdata;
-
-typedef struct common_key_info_st {
-	int cert_found;
-	int pubkey_found;
-	int pubkey_from_file;
-	int key_alg;
-	unsigned int pubkey_len;
-	int not_present;
-} common_key_info;
-
-
 /*
  * The PIV applet has no serial number, and so the either the FASC-N
  * is used, or the GUID is used as a serial number.
@@ -597,12 +536,31 @@
 				/*EC*/SC_PKCS15_PRKEY_USAGE_DERIVE,
 			"", 0x95, "1", SC_PKCS15_CO_FLAG_PRIVATE, 1}
 	};
+ 
+	common_key_info ckis[PIV_NUM_CERTS_AND_KEYS];
+
+	return sc_pkcs15emu_piv_init_helper(p15card, "PIV-II", "PIV_II",
+					    MANU_ID, objects,
+					    PIV_NUM_CERTS_AND_KEYS,
+					    certs, pins, pubkeys, prkeys, ckis);
+}
+
+int sc_pkcs15emu_piv_init_helper(sc_pkcs15_card_t *p15card,
+                                 const char *driver,
+                                 const char *label, const char *manuid,
+                                 const objdata *objects,
+				 const int num_certs_and_keys,
+                                 const cdata *certs,
+                                 const pindata *pins,
+                                 const pubdata *pubkeys,
+                                 const prdata *prkeys,
+				 common_key_info *ckis)
+{
 
 	int    r, i;
 	sc_card_t *card = p15card->card;
 	sc_serial_number_t serial;
 	char buf[SC_MAX_SERIALNR * 2 + 1];
-	common_key_info ckis[PIV_NUM_CERTS_AND_KEYS];
 
 
 	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
@@ -610,8 +568,8 @@
 	/* could read this off card if needed */
 
 	/* CSP does not like a - in the name */
-	p15card->tokeninfo->label = strdup("PIV_II");
-	p15card->tokeninfo->manufacturer_id = strdup(MANU_ID);
+	p15card->tokeninfo->label = strdup(label);
+	p15card->tokeninfo->manufacturer_id = strdup(manuid);
 
 	/*
 	 * get serial number 
@@ -629,7 +587,7 @@
 		p15card->tokeninfo->serial_number = strdup(buf);
 	}
 
-	sc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, "PIV-II adding objects...");
+	sc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, "%s adding objects...", driver);
 
 	/* set other objects */
 	for (i = 0; objects[i].label; i++) {
@@ -687,8 +645,8 @@
  
 	 */
 	/* set certs */
-	sc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, "PIV-II adding certs...");
-	for (i = 0; i < PIV_NUM_CERTS_AND_KEYS; i++) {
+	sc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, "%s adding certs...", driver);
+	for (i = 0; i < num_certs_and_keys; i++) {
 		struct sc_pkcs15_cert_info cert_info;
 		struct sc_pkcs15_object    cert_obj;
 		sc_pkcs15_der_t   cert_der;
@@ -743,14 +701,58 @@
 			case SC_ALGORITHM_RSA:
 				/* save pubkey_len for pub and priv */
 				ckis[i].pubkey_len = cert_out->key->u.rsa.modulus.len * 8;
+				ckis[i].pub_usage = pubkeys[i].usage_rsa;
+				ckis[i].pr_usage = prkeys[i].usage_rsa;
 				break;
 			case SC_ALGORITHM_EC:
 				ckis[i].pubkey_len = cert_out->key->u.ec.params.field_length;
+				ckis[i].pub_usage = pubkeys[i].usage_ec;
+				ckis[i].pr_usage = prkeys[i].usage_ec;
 				break;
 			default:
 				sc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, "Unsuported key.algorithm %d", cert_out->key->algorithm);
 				ckis[i].pubkey_len = 0; /* set some value for now */
 		}
+#ifdef ENABLE_OPENSSL
+		{
+		  X509 *x509;
+		  const u8 *throwaway = cert_out->data;
+		  x509 = d2i_X509(NULL, &throwaway, cert_out->data_len);
+		  X509_check_purpose(x509, -1, 0);
+		  if(x509->ex_flags & EXFLAG_KUSAGE) {
+		    int ku = x509->ex_kusage;
+		    int xku = x509->ex_xkusage;
+		    int pubkey_usage = 0;
+		    int prkey_usage = 0;
+		    if (ku & KU_DIGITAL_SIGNATURE) {
+		      pubkey_usage |= SC_PKCS15_PRKEY_USAGE_VERIFY | SC_PKCS15_PRKEY_USAGE_VERIFYRECOVER;
+		      prkey_usage |= SC_PKCS15_PRKEY_USAGE_SIGN | SC_PKCS15_PRKEY_USAGE_SIGNRECOVER;
+		    }
+		    if (ku & KU_NON_REPUDIATION) {
+		      pubkey_usage |= SC_PKCS15_PRKEY_USAGE_VERIFY | SC_PKCS15_PRKEY_USAGE_VERIFYRECOVER;
+		      prkey_usage |= SC_PKCS15_PRKEY_USAGE_NONREPUDIATION;
+		    }
+		    if (ku & KU_KEY_ENCIPHERMENT || xku & XKU_SSL_CLIENT) {
+		      pubkey_usage |= SC_PKCS15_PRKEY_USAGE_WRAP;
+		      prkey_usage |= SC_PKCS15_PRKEY_USAGE_UNWRAP;
+		    }
+		    if (ku & KU_KEY_AGREEMENT) {
+		      pubkey_usage |= SC_PKCS15_PRKEY_USAGE_DERIVE;
+		    }
+		    if (ku & KU_DATA_ENCIPHERMENT || ku & KU_KEY_ENCIPHERMENT || xku & XKU_SMIME) {
+		      pubkey_usage |= SC_PKCS15_PRKEY_USAGE_ENCRYPT;
+		      prkey_usage |= SC_PKCS15_PRKEY_USAGE_DECRYPT;
+		    }
+		    if (cert_out->key->algorithm == SC_ALGORITHM_EC) {
+		      pubkey_usage &= ~ SC_PKCS15_PRKEY_USAGE_VERIFYRECOVER;
+		      prkey_usage &= ~ SC_PKCS15_PRKEY_USAGE_SIGNRECOVER;
+		    }
+		    ckis[i].pub_usage = pubkey_usage;
+		    ckis[i].pr_usage = prkey_usage;
+		  }
+		  OPENSSL_free(x509);
+		}
+#endif
 		sc_pkcs15_free_certificate(cert_out);
 
 		r = sc_pkcs15emu_add_x509_cert(p15card, &cert_obj, &cert_info);
@@ -761,7 +763,7 @@
 	}
 
 	/* set pins */
-	sc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, "PIV-II adding pins...");
+	sc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, "%s adding pins...", driver);
 	for (i = 0; pins[i].label; i++) {
 		struct sc_pkcs15_auth_info pin_info;
 		struct sc_pkcs15_object   pin_obj;
@@ -807,8 +809,8 @@
 	 * gets the pubkey, but it can not be read from the card 
 	 * at a later time. The piv-tool can stach  pubkey in file 
 	 */ 
-	sc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, "PIV-II adding pub keys...");
-	for (i = 0; i < PIV_NUM_CERTS_AND_KEYS; i++) {
+	sc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, "%s adding pub keys...", driver);
+	for (i = 0; i < num_certs_and_keys; i++) {
 		struct sc_pkcs15_pubkey_info pubkey_info;
 		struct sc_pkcs15_object     pubkey_obj;
 		struct sc_pkcs15_pubkey *p15_key;
@@ -905,7 +907,7 @@
 		sc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,"adding pubkey for %d keyalg=%d",i, ckis[i].key_alg);
 		switch (ckis[i].key_alg) {
 			case SC_ALGORITHM_RSA:
-				pubkey_info.usage = pubkeys[i].usage_rsa;
+				pubkey_info.usage = ckis[i].pub_usage;
 				pubkey_info.modulus_length = ckis[i].pubkey_len;
 				strncpy(pubkey_obj.label, pubkeys[i].label, SC_PKCS15_MAX_LABEL_SIZE - 1);
 
@@ -916,7 +918,7 @@
 				ckis[i].pubkey_found = 1;
 				break;
 			case SC_ALGORITHM_EC:
-				pubkey_info.usage = pubkeys[i].usage_ec;
+				pubkey_info.usage = ckis[i].pub_usage;
 				pubkey_info.field_length = ckis[i].pubkey_len; 
 				strncpy(pubkey_obj.label, pubkeys[i].label, SC_PKCS15_MAX_LABEL_SIZE - 1);
 
@@ -933,8 +935,8 @@
 
 
 	/* set private keys */
-	sc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, "PIV-II adding private keys...");
-	for (i = 0; i < PIV_NUM_CERTS_AND_KEYS; i++) {
+	sc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, "%s adding private keys...", driver);
+	for (i = 0; i < num_certs_and_keys; i++) {
 		struct sc_pkcs15_prkey_info prkey_info;
 		struct sc_pkcs15_object     prkey_obj;
 
@@ -972,12 +974,12 @@
 
 		switch (ckis[i].key_alg) {
 			case SC_ALGORITHM_RSA: 
-				prkey_info.usage         |= prkeys[i].usage_rsa;
+				prkey_info.usage         |= ckis[i].pr_usage;
 				prkey_info.modulus_length= ckis[i].pubkey_len;
 				r = sc_pkcs15emu_add_rsa_prkey(p15card, &prkey_obj, &prkey_info);
 				break;
 		 	case SC_ALGORITHM_EC: 
-				prkey_info.usage         |= prkeys[i].usage_ec;
+				prkey_info.usage         |= ckis[i].pr_usage;
 				prkey_info.field_length = ckis[i].pubkey_len;
 				sc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, "DEE added key_alg %2.2x prkey_obj.flags %8.8x",
 					 ckis[i].key_alg, prkey_obj.flags);
diff -urN opensc-0.12.2.orig/src/libopensc/pkcs15-piv.h opensc-0.12.2/src/libopensc/pkcs15-piv.h
--- opensc-0.12.2.orig/src/libopensc/pkcs15-piv.h	1969-12-31 18:00:00.000000000 -0600
+++ opensc-0.12.2/src/libopensc/pkcs15-piv.h	2012-03-20 15:09:21.370620355 -0500
@@ -0,0 +1,90 @@
+#ifndef _OPENSC_PKCS15_PIV_H
+#define _OPENSC_PKCS15_PIV_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct objdata_st {
+	const char *id;
+	const char *label;
+	const char *aoid;
+	const char *auth_id;
+	const char *path;
+	int         obj_flags;
+} objdata;
+
+typedef struct cdata_st {
+	const char *id;
+	const char *label;
+	int	    authority;
+	const char *path;
+	int         obj_flags;
+} cdata;
+
+typedef struct pdata_st {
+	const char *id;
+	const char *label;
+	const char *path;
+	int         ref;
+	int         type;
+	unsigned int maxlen;
+	unsigned int minlen;
+	unsigned int storedlen;
+	int         flags;	
+	int         tries_left;
+	const unsigned char  pad_char;
+	int         obj_flags;
+} pindata; 
+
+typedef struct pubdata_st {
+	const char *id;
+	const char *label;
+	int         usage_rsa;
+	int         usage_ec;
+	const char *path;
+	int         ref;
+	const char *auth_id;
+	int         obj_flags;
+	const char *getenvname;
+} pubdata;
+
+typedef struct prdata_st {
+	const char *id;
+	const char *label;
+	int         usage_rsa;
+	int			usage_ec;
+	const char *path;
+	int         ref;
+	const char *auth_id;
+	int         obj_flags;
+	int			user_consent; 
+} prdata;
+
+typedef struct common_key_info_st {
+	int cert_found;
+	int pubkey_found;
+	int pubkey_from_file;
+	int key_alg;
+	unsigned int pubkey_len;
+	int not_present;
+        int pub_usage;
+	int pr_usage;
+} common_key_info;
+
+extern int sc_pkcs15emu_piv_init_helper(sc_pkcs15_card_t *p15card,
+					const char *driver,
+					const char *label, const char *manuid,
+					const objdata *objects,
+					const int num_certs_and_keys,
+					const cdata *certs,
+					const pindata *pins,
+					const pubdata *pubkeys,
+					const prdata *prkeys,
+					common_key_info *ckis);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -urN opensc-0.12.2.orig/src/libopensc/pkcs15-sec.c opensc-0.12.2/src/libopensc/pkcs15-sec.c
--- opensc-0.12.2.orig/src/libopensc/pkcs15-sec.c	2011-07-05 06:28:53.000000000 -0500
+++ opensc-0.12.2/src/libopensc/pkcs15-sec.c	2012-03-20 15:09:21.371620343 -0500
@@ -190,6 +190,9 @@
 	LOG_FUNC_CALLED(ctx);
 	sc_log(ctx, "security operation flags 0x%X", flags);
 
+	sc_debug(ctx, SC_LOG_DEBUG_NORMAL,
+		"pkcs15_compute_sig: flags=%d inlen=%d outlen=%d", flags, inlen, outlen);
+
 	memset(&senv, 0, sizeof(senv));
 
 	/* Card driver should have the access to supported algorithms from 'tokenInfo'. So that  
diff -urN opensc-0.12.2.orig/src/libopensc/pkcs15-syn.c opensc-0.12.2/src/libopensc/pkcs15-syn.c
--- opensc-0.12.2.orig/src/libopensc/pkcs15-syn.c	2011-07-05 06:28:53.000000000 -0500
+++ opensc-0.12.2/src/libopensc/pkcs15-syn.c	2012-03-20 15:09:21.372620330 -0500
@@ -46,6 +46,8 @@
 					sc_pkcs15emu_opt_t *);
 extern int sc_pkcs15emu_piv_init_ex(sc_pkcs15_card_t *p15card,
 					sc_pkcs15emu_opt_t *opts);
+extern int sc_pkcs15emu_gsc_init_ex(sc_pkcs15_card_t *p15card,
+					sc_pkcs15emu_opt_t *opts);
 extern int sc_pkcs15emu_gemsafeGPK_init_ex(sc_pkcs15_card_t *p15card,
 					sc_pkcs15emu_opt_t *opts);
 extern int sc_pkcs15emu_gemsafeV1_init_ex(sc_pkcs15_card_t *p15card,
@@ -78,6 +80,7 @@
 	{ "itacns",	sc_pkcs15emu_itacns_init_ex	},
 	{ "postecert",	sc_pkcs15emu_postecert_init_ex  },
 	{ "PIV-II",     sc_pkcs15emu_piv_init_ex        },
+	{ "GSC-IS",     sc_pkcs15emu_gsc_init_ex        },
 	{ "gemsafeGPK",	sc_pkcs15emu_gemsafeGPK_init_ex	},
 	{ "gemsafeV1",	sc_pkcs15emu_gemsafeV1_init_ex	},
 	{ "actalis",	sc_pkcs15emu_actalis_init_ex	},
